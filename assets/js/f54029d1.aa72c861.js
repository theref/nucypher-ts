"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[760],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=o,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||a;return n?r.createElement(m,i(i({ref:t},l),{},{components:n})):r.createElement(m,i({ref:t},l))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4239:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const a={slug:"cbd"},i="Condition-Based Decryption",s={unversionedId:"CBD",id:"CBD",title:"Condition-Based Decryption",description:"Condition-Based Decryption (CBD) is a programmable access control service, in which decryption rights are based on the verified fulfillment of predefined conditions.",source:"@site/docs/CBD.md",sourceDirName:".",slug:"/cbd",permalink:"/nucypher-ts/cbd",draft:!1,tags:[],version:"current",frontMatter:{slug:"cbd"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/nucypher-ts/"},next:{title:"Proxy Re-Encryption",permalink:"/nucypher-ts/pre"}},c={},p=[{value:"Build a Cohort",id:"build-a-cohort",level:2},{value:"Create a Condition",id:"create-a-condition",level:2},{value:"Build a Strategy",id:"build-a-strategy",level:2}],l={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"condition-based-decryption"},"Condition-Based Decryption"),(0,o.kt)("p",null,"Condition-Based Decryption (CBD) is a programmable access control service, in which decryption rights are based on the verified fulfillment of predefined conditions.\nAccess conditions can be EVM-based (e.g. does the requester own this NFT?), RPC-driven (e.g. does the requester have at least X amount of a given token in their wallet?) or time-based (e.g. has a preset period elapsed, after which the recipient's requests will be ignored?).\nThese conditions are also composable and can be combined in any logical sequence or decision tree."),(0,o.kt)("p",null,"CBD involves splitting a joint secret (a decryption key) into multiples ",(0,o.kt)("em",{parentName:"p"},"shares")," and distributing those among authorized and collateralized node operators (",(0,o.kt)("a",{parentName:"p",href:"https://threshold.network/earn/staker"},"Stakers")," in the Threshold network).\nA minimum number \u2013 a ",(0,o.kt)("em",{parentName:"p"},"threshold")," \u2013 of those operators holding the key shares must be online and actively participate in partial decryptions that can subsequently be combined by the requester to reconstruct the original plaintext data."),(0,o.kt)("h2",{id:"build-a-cohort"},"Build a Cohort"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"./cohort"},"Cohort")," defines the collection of nodes that will provide CBD services.\n",(0,o.kt)("em",{parentName:"p"},"Threshold")," and ",(0,o.kt)("em",{parentName:"p"},"Shares")," are two parameters used to construct a Cohort.\nFor example, a ",(0,o.kt)("inlineCode",{parentName:"p"},"3-of-5")," Cohort requires a threshold of 3 out of 5 shares to reconstruct the original plaintext data."),(0,o.kt)("p",null,"We can define a cohort by:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { Cohort } from '@nucypher/nucypher-ts';\n\nconst config = {\n  threshold: 3,\n  shares: 5,\n  porterUri: 'https://porter-ibex.nucypher.community',\n};\nconst newCohort = await Cohort.create(config);\n")),(0,o.kt)("p",null,"We also provide ",(0,o.kt)("inlineCode",{parentName:"p"},"porterUri"),".\n",(0,o.kt)("a",{parentName:"p",href:"/nucypher-ts/Glossary.md#porter"},"Porter")," is a web-based service that interacts with nodes on the network on behalf of applications.\nIn this case, we are using an ",(0,o.kt)("inlineCode",{parentName:"p"},"ibex")," porter which means we're on a testnet."),(0,o.kt)("h2",{id:"create-a-condition"},"Create a Condition"),(0,o.kt)("p",null,"Condition-Based Decryption also needs some ",(0,o.kt)("a",{parentName:"p",href:"./conditions"},"Conditions"),".\nIn this tutorial, we will check that the user owns a specific ERC721 NFT."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { Conditions } from '@nucypher/nucypher-ts';\n\nconst NFTOwnership = new Conditions.ERC721Ownership({\n  contractAddress: '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',\n  chain: 'Rinkeby', // Ibex uses Rinkeby testnet\n  parameters: ['5954'],\n});\n")),(0,o.kt)("p",null,"It is possible to compose multiple Conditions into a ",(0,o.kt)("a",{parentName:"p",href:"./condition_set"},"ConditionSet"),", but for now, we will only use one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { Conditions, ConditionSet } from '@nucypher/nucypher-ts';\n\nconst conditions = new ConditionSet([NFTOwnership]);\n")),(0,o.kt)("h2",{id:"build-a-strategy"},"Build a Strategy"),(0,o.kt)("p",null,"We combine our Cohort, Conditions, and any other extra parameters into a ",(0,o.kt)("a",{parentName:"p",href:"./strategy"},"Strategy"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { Strategy } from '@nucypher/nucypher-ts';\n\nconst newStrategy = Strategy.create(\n  newCohort,\n  new Date(),\n  new Date(Date.now() + 1000 * 60 * 60 * 24 * 30), // 30 days\n  conditions\n);\n")),(0,o.kt)("p",null,"Finally, we can deploy this Strategy to the Threshold Network, and begin using Condition-Based Decryption:"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Deploying a Strategy requires writing to the blockchain.\nThis means both a funded wallet is required and also a connection to the blockchain via a ",(0,o.kt)("inlineCode",{parentName:"p"},"provider")," (eg. MetaMask).")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import detectEthereumProvider from '@metamask/detect-provider';\nimport providers from 'ethers';\n\nconst MMprovider = await detectEthereumProvider();\nconst rinkeby = providers.providers.getNetwork('Rinkeby');\n\nif (MMprovider) {\n  const web3Provider = new providers.providers.Web3Provider(\n    MMprovider,\n    rinkeby\n  );\n  const newDeployed = await newStrategy.deploy('test', web3Provider);\n}\n")),(0,o.kt)("p",null,"Our encrypter and decrypter objects are available by:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const encrypter = newDeployed.encrypter;\nconst decrypter = newDeployed.decrypter;\n\nconst plaintext = 'this is a secret';\nconst encryptedMessageKit = encrypter.encryptMessage(plaintext);\n\nconst decryptedMessage = await decrypter.retrieveAndDecrypt([\n  encryptedMessageKit,\n]);\n")),(0,o.kt)("p",null,"At decryption time, the requester will be asked to verify their address by signing a message in MetaMask.\nAssuming they pass the conditions, the message will be decrypted successfully."))}d.isMDXComponent=!0}}]);