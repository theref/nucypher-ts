"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[767],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||o;return t?a.createElement(h,i(i({ref:n},d),{},{components:t})):a.createElement(h,i({ref:n},d))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1851:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={slug:"Conditions.md",sidebar_position:2},i="Conditions",s={unversionedId:"Conditions",id:"Conditions",title:"Conditions",description:"Several types of access conditions can be defined:",source:"@site/docs/Conditions.md",sourceDirName:".",slug:"/Conditions.md",permalink:"/nucypher-ts/Conditions.md",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{slug:"Conditions.md",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/nucypher-ts/"},next:{title:"Contribution Guide",permalink:"/nucypher-ts/Contributing.md"}},l={},c=[{value:"EVM Conditions",id:"evm-conditions",level:2},{value:"Ownership of any token in an ERC721 collection (NFT Collection)",id:"ownership-of-any-token-in-an-erc721-collection-nft-collection",level:3},{value:"Own at least one ERC20 Token",id:"own-at-least-one-erc20-token",level:3},{value:"Ownership of at least one ERC1155 token from a batch of ids",id:"ownership-of-at-least-one-erc1155-token-from-a-batch-of-ids",level:3},{value:"Function call of non standard Contract",id:"function-call-of-non-standard-contract",level:3},{value:"RPC Conditions",id:"rpc-conditions",level:2},{value:"Time Conditions",id:"time-conditions",level:2}],d={toc:c};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"conditions"},"Conditions"),(0,r.kt)("p",null,"Several types of access conditions can be defined:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"EVM - on chain state, eg NFT ownership, ETH balance, tx status, contract function call"),(0,r.kt)("li",{parentName:"ul"},"RPC - ethereum RPC calls as defined in the ",(0,r.kt)("a",{parentName:"li",href:"https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods"},"Official API")),(0,r.kt)("li",{parentName:"ul"},"Timelock - time based conditions, eg Block Time, Block Height, UTC Time")),(0,r.kt)("h2",{id:"evm-conditions"},"EVM Conditions"),(0,r.kt)("p",null,"Here is an example EVM condition for ownership of a specific ERC721 token (NFT):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const ERC721Conditions = {\n    contractAddress: "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D",\n    standardContractType: "ERC721",\n    chain:  "ethereum",\n    method: "ownerOf",\n    parameters: [\n      "5954"\n    ],\n    returnValueTest: {\n      comparator: "=",\n      value: ":userAddress"\n    }\n  }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"contractAddress")," is the public address of the contract we'd like to query."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"standardContractType")," can take values from ",(0,r.kt)("inlineCode",{parentName:"li"},"ERC20, ERC721")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ERC1155"),". Alternatively, an ABI can be passed through if a non standard contract is being used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"chain")," currently only ",(0,r.kt)("inlineCode",{parentName:"li"},"ethereum")," is supported, please ",(0,r.kt)("a",{parentName:"li",href:"https://discord.gg/RwjHbgA7uQ"},"Contact Us")," if you require non ethereum based conditions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method")," the contract method that will be called."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"parameters")," the parameters that will be passed to the contract's ",(0,r.kt)("inlineCode",{parentName:"li"},"method"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"returnValueTest")," defines how the return value of the contract call should be evaluated.")),(0,r.kt)("p",null,"In the above example, we query the ",(0,r.kt)("inlineCode",{parentName:"p"},"ownerOf")," method of an ",(0,r.kt)("inlineCode",{parentName:"p"},"ERC721")," token contract which is located at ",(0,r.kt)("inlineCode",{parentName:"p"},"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D"),".\nWe are testing whether the ",(0,r.kt)("inlineCode",{parentName:"p"},"ownerOf")," token number ",(0,r.kt)("inlineCode",{parentName:"p"},"5954")," is the current user.\nThe symbol ",(0,r.kt)("inlineCode",{parentName:"p"},":userAddress")," is how we define the current user, who will have to authenticate themselves by signing a message using a tool such as MetaMask."),(0,r.kt)("h3",{id:"ownership-of-any-token-in-an-erc721-collection-nft-collection"},"Ownership of any token in an ERC721 collection (NFT Collection)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const ERC721Conditions = {\n    contractAddress: "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D",\n    standardContractType: "ERC721",\n    chain:  "ethereum",\n    method: "blanceOf",\n    parameters: [\n      ":userAddress"\n    ],\n    returnValueTest: {\n      comparator: ">",\n      value: "0"\n    }\n  }\n')),(0,r.kt)("h3",{id:"own-at-least-one-erc20-token"},"Own at least one ERC20 Token"),(0,r.kt)("p",null,"Here we're checking whether the user owns any ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," Threshold Network token"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const ERC20Conditions = {\n    contractAddress: "0xCdF7028ceAB81fA0C6971208e83fa7872994beE5",\n    standardContractType: "ERC20",\n    chain:  "ethereum",\n    method: "blanceOf",\n    parameters: [\n      ":userAddress"\n    ],\n    returnValueTest: {\n      comparator: ">",\n      value: "0"\n    }\n  }\n')),(0,r.kt)("h3",{id:"ownership-of-at-least-one-erc1155-token-from-a-batch-of-ids"},"Ownership of at least one ERC1155 token from a batch of ids"),(0,r.kt)("p",null,"Batching can be applied to ERC721 tokens as well."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const ERC115Conditions = {\n    contractAddress: "0x54F456B544abFb785694400bcb1D85629B2D437f",\n    standardContractType: "ERC115",\n    chain:  "ethereum",\n    method: "blanceOfBatch",\n    parameters: [\n      ":userAddress,:userAddress,:userAddress,:userAddress",\n      "1,2,1001,1002"\n    ],\n    returnValueTest: {\n      comparator: ">",\n      value: "0"\n    }\n  }\n')),(0,r.kt)("h3",{id:"function-call-of-non-standard-contract"},"Function call of non standard Contract"),(0,r.kt)("p",null,"In this example we will check that the user is staking ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," Threshold Token.\nThe Threshold staking contract is located at ",(0,r.kt)("a",{parentName:"p",href:"https://etherscan.io/address/0x01b67b1194c75264d06f808a921228a95c765dd7#readProxyContract"},(0,r.kt)("inlineCode",{parentName:"a"},"0x01B67b1194C75264d06F808A921228a95C765dd7")),".\nThe function we wish to call is ",(0,r.kt)("inlineCode",{parentName:"p"},"stakes")," which takes an ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," as it's parameter.\nWe need to provide the ",(0,r.kt)("inlineCode",{parentName:"p"},"contractAddress"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"functionName"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"functionParams"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"functionAbi")," when defining the condition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const customABICondition = {\n    contractAddress: "00x01B67b1194C75264d06F808A921228a95C765dd7",\n    functionName: "stakes",\n    functionParams: [":userAddress"],\n    functionAbi: {\n        inputs: [\n        {\n            internalType: "address",\n            name: "stakingProvider",\n            type: "address"\n        }\n        ],\n        name: "stakes",\n        outputs: [\n        {\n            internalType: "uint96",\n            name: "tStake",\n            type: "uint96"\n        },\n        {\n            internalType: "uint96",\n            name: "keepInTStake",\n            type: "uint96"\n        },\n        {\n            internalType: "uint96",\n            name: "nuInTStake",\n            type: "uint96"\n        }\n        ],\n        stateMutability: "view",\n        type: "function"\n    },\n    chain:  "ethereum",\n    returnValueTest: {\n      key: "tStake",\n      comparator: ">",\n      value: "0"\n    }\n  }\n')),(0,r.kt)("h2",{id:"rpc-conditions"},"RPC Conditions"),(0,r.kt)("p",null,"Here will will query the ETH balance of the users address using the RPC call ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance"},(0,r.kt)("inlineCode",{parentName:"a"},"eth_getBalance"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const ETHBalance = {\n    contractAddress: "",\n    standardContractType: "",\n    chain:  "ethereum",\n    method: "eth_getBalance",\n    parameters: [\n      ":userAddress",\n      "latest"\n    ],\n    returnValueTest: {\n      comparator: ">=",\n      value: "10000000000000"\n    }\n  }\n')),(0,r.kt)("h2",{id:"time-conditions"},"Time Conditions"))}p.isMDXComponent=!0}}]);