"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[767],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=a,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return t?o.createElement(h,r(r({ref:n},d),{},{components:t})):o.createElement(h,r({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1851:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=t(7462),a=(t(7294),t(3905));const i={slug:"conditions"},r="Conditions",s={unversionedId:"Conditions",id:"Conditions",title:"Conditions",description:"Several types of access conditions can be defined:",source:"@site/docs/Conditions.md",sourceDirName:".",slug:"/conditions",permalink:"/nucypher-ts/conditions",draft:!1,tags:[],version:"current",frontMatter:{slug:"conditions"},sidebar:"tutorialSidebar",previous:{title:"Cohort",permalink:"/nucypher-ts/cohort"},next:{title:"Condition Set",permalink:"/nucypher-ts/condition_set"}},l={},c=[{value:"<code>Conditions.ERC721Ownership</code>",id:"conditionserc721ownership",level:2},{value:"<code>Conditions.ERC721Balance</code>",id:"conditionserc721balance",level:2},{value:"<code>Conditions.TimelockCondition</code>",id:"conditionstimelockcondition",level:2},{value:"<code>Conditions.RpcCondition</code>",id:"conditionsrpccondition",level:2},{value:"<code>Conditions.Condition</code>",id:"conditionscondition",level:2},{value:"Non Zero balance of ERC20 Token",id:"non-zero-balance-of-erc20-token",level:3},{value:"Ownership of at least one ERC1155 token from a batch of ids",id:"ownership-of-at-least-one-erc1155-token-from-a-batch-of-ids",level:3},{value:"Function call of nonstandard Contract",id:"function-call-of-nonstandard-contract",level:3}],d={toc:c};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"conditions"},"Conditions"),(0,a.kt)("p",null,"Several types of access conditions can be defined:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"EVM - on-chain state, eg NFT ownership, ETH balance, tx status, contract function call"),(0,a.kt)("li",{parentName:"ul"},"RPC - ethereum RPC calls as defined in the ",(0,a.kt)("a",{parentName:"li",href:"https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods"},"Official API")),(0,a.kt)("li",{parentName:"ul"},"Timelock - time-based conditions, eg Block Height")),(0,a.kt)("p",null,"We provide many helper objects to streamline the creation of common conditions.\nAn expressive API also allows much more granular control of conditions, and we will provide examples of both methods wherever possible."),(0,a.kt)("h2",{id:"conditionserc721ownership"},(0,a.kt)("inlineCode",{parentName:"h2"},"Conditions.ERC721Ownership")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Conditions.ERC721Ownership")," is a shortcut for building conditions that test for ownership of a specific ERC721 token (NFT):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const NFTOwnership = new Conditions.ERC721Ownership({\n  contractAddress: '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',\n  parameters: [5954],\n});\n")),(0,a.kt)("p",null,"If we want to be more verbose we can use ",(0,a.kt)("inlineCode",{parentName:"p"},"Conditions.Condition"),".\nThe above and below examples are completely equivalent:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const NFTOwnershipConfig = {\n  contractAddress: '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',\n  standardContractType: 'ERC721',\n  chain: 'ethereum',\n  method: 'ownerOf',\n  parameters: ['5954'],\n  returnValueTest: {\n    comparator: '==',\n    value: ':userAddress',\n  },\n};\nconst NFTOwnership = new Conditions.Condition(NFTOwnershipConfig);\n")),(0,a.kt)("h2",{id:"conditionserc721balance"},(0,a.kt)("inlineCode",{parentName:"h2"},"Conditions.ERC721Balance")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Conditions.ERC721Balance")," is a shortcut for building conditions that test for ownership of at least one ERC721 token (NFT) within a collection."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const NFTBalance = new Conditions.ERC721Balance({\n  contractAddress: '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',\n});\n")),(0,a.kt)("p",null,"Alternatively:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const NFTBalanceConfig = {\n  contractAddress: '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',\n  standardContractType: 'ERC721',\n  chain: 'ethereum',\n  method: 'balanceOf',\n  parameters: [':userAddress'],\n  returnValueTest: {\n    comparator: '>',\n    value: '0',\n  },\n};\n\nconst NFTBalance = new Conditions.Condition(NFTBalanceConfig);\n")),(0,a.kt)("h2",{id:"conditionstimelockcondition"},(0,a.kt)("inlineCode",{parentName:"h2"},"Conditions.TimelockCondition")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Conditions.TimelockCondition")," is a shortcut for building conditions that test against block height."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const timelock = Conditions.TimelockCondition({\n  returnValueTest: {\n    comparator: '>',\n    value: '100',\n  },\n});\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const timelockConfig = {\n  contractAddress: '',\n  standardContractType: '',\n  chain: 'ethereum',\n  method: 'timelock',\n  returnValueTest: {\n    comparator: '>',\n    value: '100',\n  },\n};\nconst timelock = Conditions.Condition(timelockConfig);\n")),(0,a.kt)("h2",{id:"conditionsrpccondition"},(0,a.kt)("inlineCode",{parentName:"h2"},"Conditions.RpcCondition")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Conditions.RpcCondition")," is a shortcut for building conditions that test against standard ",(0,a.kt)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/apis/json-rpc/"},"RPC calls")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const const rpc = new Conditions.RpcCondition({\n  chain: \'ethereum\',\n  method: \'eth_getBalance\',\n  parameters: [\n      ":userAddress",\n      "latest"\n    ],\n  returnValueTest: {\n    comparator: ">=",\n    value: "10000000000000"\n  }\n});\n')),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const rpcConfig = {\n  contractAddress: '',\n  standardContractType: '',\n  chain: 'ethereum',\n  method: 'eth_getBalance',\n  parameters: [':userAddress', 'latest'],\n  returnValueTest: {\n    comparator: '>=',\n    value: '10000000000000',\n  },\n};\nconst rpc = Conditions.Condition(rpcConfig);\n")),(0,a.kt)("h2",{id:"conditionscondition"},(0,a.kt)("inlineCode",{parentName:"h2"},"Conditions.Condition")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Conditions.Condition")," provides full control over the configuration of a Condition.\nIt takes parameters:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"contractAddress")," is the public address of the contract we'd like to query."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"standardContractType")," can take values from ",(0,a.kt)("inlineCode",{parentName:"li"},"ERC20, ERC721")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"ERC1155"),". Alternatively, an ABI can be passed through if a non standard contract is being used."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"functionAbi")," is the ABI of the function we'd like to call. This is optional if the contract is a standard ",(0,a.kt)("inlineCode",{parentName:"li"},"ERC20"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"ERC721")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"ERC1155"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"chain")," - currently only ",(0,a.kt)("inlineCode",{parentName:"li"},"ethereum")," is supported, please ",(0,a.kt)("a",{parentName:"li",href:"https://discord.gg/RwjHbgA7uQ"},"Contact Us")," if you require non-Ethereum based conditions."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"method")," the contract method that will be called."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"parameters")," are the parameters that will be passed to the contract's ",(0,a.kt)("inlineCode",{parentName:"li"},"method"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"returnValueTest")," defines how the return value of the contract call should be evaluated.")),(0,a.kt)("h3",{id:"non-zero-balance-of-erc20-token"},"Non Zero balance of ERC20 Token"),(0,a.kt)("p",null,"Here we're checking whether the user owns any ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," Threshold Network token:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const ERC20Conditions = {\n  contractAddress: '0xCdF7028ceAB81fA0C6971208e83fa7872994beE5',\n  standardContractType: 'ERC20',\n  chain: 'ethereum',\n  method: 'balanceOf',\n  parameters: [':userAddress'],\n  returnValueTest: {\n    comparator: '>',\n    value: '0',\n  },\n};\n")),(0,a.kt)("h3",{id:"ownership-of-at-least-one-erc1155-token-from-a-batch-of-ids"},"Ownership of at least one ERC1155 token from a batch of ids"),(0,a.kt)("p",null,"Batching can be applied to ERC721 tokens as well."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const ERC1155Conditions = {\n  contractAddress: '0x54F456B544abFb785694400bcb1D85629B2D437f',\n  standardContractType: 'ERC1155',\n  chain: 'ethereum',\n  method: 'blanceOfBatch',\n  parameters: [\n    ':userAddress,:userAddress,:userAddress,:userAddress',\n    '1,2,1001,1002',\n  ],\n  returnValueTest: {\n    comparator: '>',\n    value: '0',\n  },\n};\n")),(0,a.kt)("h3",{id:"function-call-of-nonstandard-contract"},"Function call of nonstandard Contract"),(0,a.kt)("p",null,"In this example, we will check that the user is staking ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," Threshold Token.\nThe Threshold staking contract is located at ",(0,a.kt)("a",{parentName:"p",href:"https://etherscan.io/address/0x01b67b1194c75264d06f808a921228a95c765dd7#readProxyContract"},(0,a.kt)("inlineCode",{parentName:"a"},"0x01B67b1194C75264d06F808A921228a95C765dd7")),".\nThe function we wish to call is ",(0,a.kt)("inlineCode",{parentName:"p"},"stakes")," which takes an ",(0,a.kt)("inlineCode",{parentName:"p"},"address")," as its parameter.\nWe need to provide the ",(0,a.kt)("inlineCode",{parentName:"p"},"contractAddress"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"functionName"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"functionParams"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"functionAbi")," when defining the condition."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const customABICondition = {\n  contractAddress: '0x01B67b1194C75264d06F808A921228a95C765dd7',\n  functionName: 'stakes',\n  functionParams: [':userAddress'],\n  functionAbi: {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'stakingProvider',\n        type: 'address',\n      },\n    ],\n    name: 'stakes',\n    outputs: [\n      {\n        internalType: 'uint96',\n        name: 'tStake',\n        type: 'uint96',\n      },\n      {\n        internalType: 'uint96',\n        name: 'keepInTStake',\n        type: 'uint96',\n      },\n      {\n        internalType: 'uint96',\n        name: 'nuInTStake',\n        type: 'uint96',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  chain: 'ethereum',\n  returnValueTest: {\n    key: 'tStake',\n    comparator: '>',\n    value: '0',\n  },\n};\n")))}p.isMDXComponent=!0}}]);